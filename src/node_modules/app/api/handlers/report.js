import {find, map, forEach, range, indexOf, isUndefined, wait} from "app/core/utils"
import {fromCache, TTL_SHORT} from "app/core/utils/cache"
import {findById as findReportById, create as createNewReport} from "app/core/models/report"
import {findById as findUserById} from "app/core/models/user"
import {findBySource as findGeosBySource} from "app/core/models/geo"
import {getNextSessionId, create as createMapResult} from "app/core/models/mapResult"
import * as layerByType from "app/tile/layers"
import random from "app/core/utils/random"

export function getReport(request) {
  return findReportById(+request.params.id)
  .then(wait(1000))
}

export function createReport(request) {
  return findUserById(request.auth.credentials.id)
  .then(user => createNewReport({
    author: user,
    config: request.payload
  }))
}

function getCategoryData(report, category, locationType, year, codes) {
  return fromCache(`categoryData/${report.id}/${report.version}/${category.id}/${locationType}/${year}`, TTL_SHORT,
  key => {
    const rng = random(key)
    const valueByCode = {}
    codes.forEach(code => {
      valueByCode[code] = rng.natural({min: 10000, max: 100000}) * 10
    })
    return valueByCode
  })
}

function getViewRecordsInTimeRange(report, view, startYear, endYear) {
  const {locationType, locations, categories} = view
  return findGeosBySource(locationType)
  .then(geos => {
    const codes = map(geos, "code")
    const allRecords = []
    const promises = []
    categories.forEach(categoryId => {
      const category = find(report.config.categories, "id", categoryId)
      const records = []
      geos.forEach(({code}) => {
        if (indexOf(locations, code) === -1) {
          return
        }
        const record = {
          code,
          category: categoryId,
          data: {}
        }
        records.push(record)
        allRecords.push(record)
      })
      range(startYear, endYear + 1).forEach(year => {
        promises.push(getCategoryData(report, category, locationType, year, codes)
        .then(valueByCode => {
          records.forEach(({code, data}) => {
            data[year] = valueByCode[code]
          })
        }))
      })
    })
    return Promise.all(promises)
    .then(() => allRecords)
  })
}

function getViewRecordsByLocationType(report, view, year, categoriesByLocationType) {
  const recordsByLocationType = {}
  return Promise.all(map(categoriesByLocationType, (categories, locationType) => {
    const records = recordsByLocationType[locationType] = []
    const recordByCode = {}
    return findGeosBySource(locationType)
    .then(geos => geos.map(({code}) => {
      const record = {
        code,
        data: {}
      }
      records.push(record)
      recordByCode[code] = record
      return code
    }))
    .then(codes => {
      return Promise.all(categories.map(category => {
        return getCategoryData(report, category, locationType, year, codes)
        .then(valueByCode => {
          forEach(valueByCode, (value, code) => {
            const {data} = recordByCode[code]
            data[category.id] = value
          })
        })
      }))
    })
  }))
  .then(() => recordsByLocationType)
}

function calculateMapResult(sessionId, resultId, layers, recordsByLocationType) {
  const mapResult = []
  return Promise.all(layers.map(layer => {
    const {type, locationType, category: categoryId} = layer
    const records = recordsByLocationType[locationType]
    const layerRecords = []
    records.forEach(({code, data}) => {
      const value = data[categoryId]
      if (isUndefined(value)) {
        return
      }
      layerRecords.push({
        code,
        value
      })
    })
    const layerResults = layerByType[type].createResults(layer, layerRecords)
    mapResult.push(layerResults)
  }))
  .then(() => {
    return createMapResult(sessionId, resultId, mapResult)
  })
}

export function getTrendsData(request) {
  return findReportById(+request.params.id)
  .then(report => {
    const view = find(report.config.views, "id", +request.params.viewId)
    const endYear = 2014
    const startYear = endYear - +view.timeRange.substring(4) + 1
    return getViewRecordsInTimeRange(report, view, startYear, endYear)
  })
  .then(wait(1000))
}

export function getMapData(request) {
  return findReportById(+request.params.id)
  .then(report => {
    const view = find(report.config.views, "id", +request.params.viewId)
    const {query} = request
    const requestId = +query.requestId
    const year = +query.year
    const resultId = +`${requestId}${year}`
    const categoriesByLocationType = {}
    view.layers.forEach(({locationType, category: categoryId}) => {
      const category = find(report.config.categories, "id", categoryId)
      const categories = categoriesByLocationType[locationType]
        || (categoriesByLocationType[locationType] = [])
      categories.push(category)
    })
    const sessionIdPromise = query.sessionId ? Promise.resolve(+query.sessionId) : getNextSessionId()
    return getViewRecordsByLocationType(report, view, year, categoriesByLocationType)
    .then(recordsByLocationType => {
      return sessionIdPromise
      .then(sessionId => {
        return calculateMapResult(sessionId, resultId, view.layers, recordsByLocationType)
        .then(() => ({
          sessionId,
          recordsByLocationType
        }))
      })
    })
  })
  .then(wait(1000))
}
