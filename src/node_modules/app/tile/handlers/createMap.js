import path from "path"
import mapnik from "mapnik"
import SphericalMercator from "sphericalmercator"
import lru from "lru-cache"
import config from "app/config"
import * as layerByType from "app/tile/layers"
import {find} from "app/core/utils"
import reports from "app/web/mock/reports"

const layersPath = path.join(__dirname, "../layers")

const sphericalMercator = new SphericalMercator()

const mapOptionsCache = lru({
  max: 10000,
  maxAge: 180000
})

const dataSourceOptions = {
  type: "postgis",
  srid: "900913",
  host: config.database.host,
  dbname: config.database.name,
  user: config.database.user,
  password: config.database.password,
  extent: config.tile.extent,
  "geometry_table": "geo",
  "geometry_field": "geom",
  "simplify_geometries": true
}

mapnik.register_default_input_plugins()

function getHiddenIndex(request) {
  const hiddenIndex = {}
  if (request.query.h) {
    request.query.h.split(",").forEach(index => {
      hiddenIndex[index] = true
    })
  }
  return hiddenIndex
}

function getLayerQuery(layer, index, request) {
  const layerName = `${layer.type}${index}`
  const columns = "resultbycode->>code as result"
  const table = `geo, (select data->${index} as resultbycode from mapresult
    where sessionid = ${request.query.sessionId} and resultid = ${request.query.resultId}) layerresult`
  const layerQuery = layerByType[layer.type].createQuery(layer, {
    columns,
    table,
    layerName,
    request
  })
  layerQuery.layerName = layerName
  if (!layerQuery.query) {
    layerQuery.query = `select ${layerQuery.geomColumn || "geom"} as geom, ${columns} from ${table}
      where source = '${layer.source}'`
  }
  return layerQuery
}

function createMapLayer(layerQuery) {
  const mapLayer = new mapnik.Layer(layerQuery.layerName)
  mapLayer.datasource = new mapnik.Datasource({
    ...dataSourceOptions,
    table: `(${layerQuery.query}) as data`
  })
  mapLayer.styles = [layerQuery.layerName]
  return mapLayer
}

function getMapOptions(request) {
  const report = find(reports, "id", +request.params.id)
  const view = find(report.views, "id", +request.params.viewId)
  const key = `${request.params.id}/${request.params.viewId}${request.url.search || ""}`
  let mapOptions = mapOptionsCache.get(key)
  if (!mapOptions) {
    const mapStyles = []
    const mapLayers = []
    let mapBufferSize = 0
    const hiddenIndex = getHiddenIndex(request)
    view.layers.forEach((layer, index) => {
      if (hiddenIndex[index]) {
        return
      }
      const layerQuery = getLayerQuery(layer, index, request)
      mapStyles.push(layerQuery.style)
      mapLayers.push(createMapLayer(layerQuery))
      if (layerQuery.bufferSize && layerQuery.bufferSize > mapBufferSize) {
        mapBufferSize = layerQuery.bufferSize
      }
    })
    mapOptions = {
      style: `<?xml version="1.0" encoding="utf-8"?><Map>${mapStyles.join("")}</Map>`,
      layers: mapLayers,
      bufferSize: mapBufferSize
    }
    mapOptionsCache.set(key, mapOptions)
  }
  return mapOptions
}

function createMap(request) {
  const mapOptions = getMapOptions(request)
  const map = new mapnik.Map(256, 256)
  map.bufferSize = mapOptions.bufferSize
  return new Promise((resolve, reject) => {
    map.fromString(mapOptions.style, {
      base: layersPath
    }, error => {
      if (error) {
        reject(error)
        return
      }
      const {x, y, z} = request.params
      map.extent = sphericalMercator.bbox(+x, +y, +z, false, "900913")
      mapOptions.layers.forEach(layer => {
        map.add_layer(layer)
      })
      resolve(map)
    })
  })
}

export default createMap
