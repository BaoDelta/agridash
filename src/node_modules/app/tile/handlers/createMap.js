import path from "path"
import mapnik from "mapnik"
import SphericalMercator from "sphericalmercator"
import lru from "lru-cache"
import config from "app/config"
import * as layerByType from "app/tile/layers"
import {find} from "app/core/utils"
import {findById as findReportById} from "app/core/models/report"

const layersPath = path.join(__dirname, "../layers")

const sphericalMercator = new SphericalMercator()

const mapOptionsCache = lru({
  max: 10000,
  maxAge: 180000
})

const dataSourceOptions = {
  type: "postgis",
  srid: "900913",
  host: config.database.host,
  dbname: config.database.name,
  user: config.database.user,
  password: config.database.password,
  extent: config.tile.extent,
  "geometry_table": "geo",
  "geometry_field": "geom",
  "simplify_geometries": true
}

mapnik.register_default_input_plugins()

function getHiddenIndex(request) {
  const hiddenIndex = {}
  if (request.query.h) {
    request.query.h.split(",").forEach(index => {
      hiddenIndex[index] = true
    })
  }
  return hiddenIndex
}

function getLayerQuery(layer, index, request) {
  const layerName = `${layer.type}${index}`
  const columns = "resultbycode->>code as result"
  const table = `geo, (select data->${index} as resultbycode from mapresult
    where sessionid = ${request.query.sessionId} and resultid = ${request.query.resultId}) layerresult`
  const layerQuery = layerByType[layer.type].createQuery(layer, {
    columns,
    table,
    layerName,
    request
  })
  layerQuery.layerName = layerName
  if (!layerQuery.query) {
    layerQuery.query = `select ${layerQuery.geomColumn || "geom"} as geom, ${columns} from ${table}
      where source = '${layer.locationType}'`
  }
  return layerQuery
}

function createMapLayer(layerQuery) {
  const mapLayer = new mapnik.Layer(layerQuery.layerName)
  mapLayer.datasource = new mapnik.Datasource({
    ...dataSourceOptions,
    table: `(${layerQuery.query}) as data`
  })
  mapLayer.styles = [layerQuery.layerName]
  return mapLayer
}

function getMapOptions(request) {
  return findReportById(+request.params.id)
  .then(report => {
    const view = find(report.config.views, "id", +request.params.viewId)
    const key = `${report.id}/${report.version}/${view.id}${request.url.search || ""}`
    let mapOptions = mapOptionsCache.get(key)
    if (!mapOptions) {
      const mapStyles = []
      const mapLayers = []
      let mapBufferSize = 0
      const hiddenIndex = getHiddenIndex(request)
      view.layers.forEach((layer, index) => {
        if (hiddenIndex[index]) {
          return
        }
        const layerQuery = getLayerQuery(layer, index, request)
        mapStyles.push(layerQuery.style)
        mapLayers.push(createMapLayer(layerQuery))
        if (layerQuery.bufferSize && layerQuery.bufferSize > mapBufferSize) {
          mapBufferSize = layerQuery.bufferSize
        }
      })
      mapOptions = {
        style: `<?xml version="1.0" encoding="utf-8"?><Map>${mapStyles.join("")}</Map>`,
        layers: mapLayers,
        bufferSize: mapBufferSize
      }
      mapOptionsCache.set(key, mapOptions)
    }
    return mapOptions
  })
}

function createMap(request) {
  return new Promise((resolve, reject) => {
    return getMapOptions(request)
    .then(mapOptions => {
      const map = new mapnik.Map(256, 256)
      map.bufferSize = mapOptions.bufferSize
      map.fromString(mapOptions.style, {
        base: layersPath
      }, error => {
        if (error) {
          reject(error)
          return
        }
        const {x, y, z} = request.params
        map.extent = sphericalMercator.bbox(+x, +y, +z, false, "900913")
        mapOptions.layers.forEach(layer => {
          map.add_layer(layer)
        })
        resolve(map)
      })
    })
    .catch(reject)
  })
}

export default createMap
