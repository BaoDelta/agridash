import path from "path"
import mapnik from "mapnik"
import SphericalMercator from "sphericalmercator"
import lru from "lru-cache"
import config from "app/config"
import * as layerByType from "app/tile/layers"
import {find} from "app/core/utils"
import reports from "app/web/mock/reports"

const layersPath = path.join(__dirname, "../layers")

const merc = new SphericalMercator()

const mapOptionsCache = lru({
  max: 10000,
  maxAge: 180000
})

const dataSourceOptions = {
  type: "postgis",
  srid: "900913",
  host: config.database.host,
  dbname: config.database.name,
  user: config.database.user,
  password: config.database.password,
  extent: config.tile.extent,
  "geometry_table": "geo",
  "geometry_field": "geom",
  "simplify_geometries": true
}

mapnik.register_default_input_plugins()

function getMapOptions(request) {
  const report = find(reports, "id", +request.params.id)
  const view = find(report.views, "id", +request.params.viewId)
  const key = `${request.params.id}/${request.params.viewId}${request.url.search || ""}`
  let mapOptions = mapOptionsCache.get(key)
  if (!mapOptions) {
    const layers = []
    const styles = []
    let bufferSize = 0
    const hiddenIndex = {}
    if (request.query.h) {
      request.query.h.split(",").forEach(index => {
        hiddenIndex[index] = true
      })
    }
    view.layers.forEach((viewLayer, index) => {
      if (hiddenIndex[index]) {
        return
      }
      const layerName = `${viewLayer.type}${index}`
      const queryColumns = "resultbycode->>code as result"
      const queryTable = `geo, (select data->0 as resultbycode from georesult
        where sessionid = ${request.query.sessionId} and resultid = ${request.query.resultId}) layerresult`
      const layerOptions = layerByType[viewLayer.type]({
        ...viewLayer,
        queryColumns,
        queryTable,
        styleName: layerName
      })
      if (!layerOptions.query) {
        layerOptions.query = `select ${layerOptions.geomColumn || "geom"} as geom, ${queryColumns}
          from ${queryTable} where source = '${viewLayer.source}'`
      }
      const layer = new mapnik.Layer(layerName)
      layer.datasource = new mapnik.Datasource({
        ...dataSourceOptions,
        table: `(${layerOptions.query}) as data`
      })
      layer.styles = [layerName]
      layers.push(layer)
      styles.push(layerOptions.style)
      if (layerOptions.bufferSize && layerOptions.bufferSize > bufferSize) {
        bufferSize = layerOptions.bufferSize
      }
    })
    mapOptions = {
      layers,
      bufferSize,
      style: `<?xml version="1.0" encoding="utf-8"?><Map>${styles.join("")}</Map>`
    }
    mapOptionsCache.set(key, mapOptions)
  }
  return mapOptions
}

function createMap(request) {
  const mapOptions = getMapOptions(request)
  const map = new mapnik.Map(256, 256)
  map.bufferSize = mapOptions.bufferSize
  return new Promise((resolve, reject) => {
    map.fromString(mapOptions.style, {
      base: layersPath
    }, err => {
      if (err) {
        reject(err)
        return
      }
      const {x, y, z} = request.params
      map.extent = merc.bbox(+x, +y, +z, false, "900913")
      mapOptions.layers.forEach(layer => {
        map.add_layer(layer)
      })
      resolve(map)
    })
  })
}

export default createMap
